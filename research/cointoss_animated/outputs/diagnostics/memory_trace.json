{
  "posterior_params": [
    377.0,
    135.0
  ],
  "trace": "Product memory:\n Message mapping memory:\n    At the node: Beta\n    Towards interface: Val{:out}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:a, :b)}() edges: (BayesBase.PointMass{Float64}(4.0), BayesBase.PointMass{Float64}(8.0))\n    With the result: Beta{Float64}(α=4.0, β=8.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n",
  "full_trace": "Product memory:\n Message mapping memory:\n    At the node: Beta\n    Towards interface: Val{:out}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:a, :b)}() edges: (BayesBase.PointMass{Float64}(4.0), BayesBase.PointMass{Float64}(8.0))\n    With the result: Beta{Float64}(α=4.0, β=8.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(0.0),)\n    With the result: Beta{Float64}(α=1.0, β=2.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n Message mapping memory:\n    At the node: Bernoulli\n    Towards interface: Val{:p}()\n    With local constraint: ReactiveMP.Marginalisation()\n    With addons: (AddonMemory(nothing),)\n    With input marginals on Val{(:out,)}() edges: (BayesBase.PointMass{Float64}(1.0),)\n    With the result: Beta{Float64}(α=2.0, β=1.0)\n",
  "messages": [],
  "posterior_type": "ReactiveMP.Marginal{Beta{Float64}, Tuple{ReactiveMP.AddonMemory{ReactiveMP.AddonMemoryProd{Any}}}}",
  "variable": "θ"
}
