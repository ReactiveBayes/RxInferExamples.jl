### Static vs Realtime: Why estimates coincide

In this example, both static and realtime modes implement the same Bayesian filtering computation over the same observation stream:

- Model: identical `@model` and `@constraints` (random-walk latent; unknown observation precision `Ï„`).
- Priors and updates: identical `@initialization` and `@autoupdates`.
- Data: identical sequence of observations generated by the same `Environment`.
- Optimization: same number of variational update iterations per time step.

Because both modes consume the same data with the same update rules and state carryover (the autoupdates propagate `q(x_current)` to the next step), their posterior means for `x_current` match step-by-step. Hence the scatter plot of static vs realtime means lies on the line y=x.

When might they differ?
- Different iteration budgets, damping, or convergence criteria per step.
- Different streaming cadence causing backpressure, dropped samples, or timing-related truncation.
- Stochastic initialization per step or nondeterministic data generation (if RNG state is not controlled).
- Different history retention or scheduling of updates.

What we check here:
- We compute MSE/MAE against truth separately for static and realtime and expect comparable values.
- We render `means_compare.png` and `scatter_static_vs_realtime.png` to visually confirm equivalence.
- Tests assert numerical equality within a small tolerance across overlapping indices.


